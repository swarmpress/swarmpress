---
/**
 * Editorial Intro Block - JSON-compatible wrapper
 * Renders EditorialIntro with content from props instead of slots
 * Supports both string and multi-language object formats
 */
import { marked } from 'marked';

type LocalizedText = string | { en?: string; de?: string; fr?: string; it?: string };
type LocalizedArray = string[] | { en?: string[]; de?: string[]; fr?: string[]; it?: string[] };

interface Props {
  badge: LocalizedText;
  quote: LocalizedText;
  content?: LocalizedArray;
  leftContent?: LocalizedText;
  rightContent?: LocalizedText;
  locale?: string;
}

const { badge: badgeProp, quote: quoteProp, content: contentProp, leftContent: leftProp, rightContent: rightProp, locale = 'en' } = Astro.props;

// Helper to get localized text
function getText(value: LocalizedText | undefined, lang: string): string {
  if (!value) return '';
  if (typeof value === 'string') return value;
  return value[lang as keyof typeof value] || value.en || Object.values(value)[0] || '';
}

// Helper to get localized array
function getArray(value: LocalizedArray | undefined, lang: string): string[] {
  if (!value) return [];
  if (Array.isArray(value)) {
    // Each item in the array might be a LocalizedText object
    return value.map(item => {
      if (typeof item === 'string') return item;
      if (typeof item === 'object' && item !== null) {
        return (item as Record<string, string>)[lang] || (item as Record<string, string>).en || Object.values(item)[0] || '';
      }
      return '';
    });
  }
  return value[lang as keyof typeof value] || value.en || Object.values(value)[0] || [];
}

const badge = getText(badgeProp, locale);
const quote = getText(quoteProp, locale);

// Handle content array format (splits into left/right columns)
const contentArray = getArray(contentProp, locale);
let leftContent = getText(leftProp, locale);
let rightContent = getText(rightProp, locale);

// If content array provided, split into two columns
if (contentArray.length > 0 && !leftContent && !rightContent) {
  const mid = Math.ceil(contentArray.length / 2);
  const leftItems = contentArray.slice(0, mid);
  const rightItems = contentArray.slice(mid);
  leftContent = leftItems.map(item => marked.parse(item)).join('');
  rightContent = rightItems.map(item => marked.parse(item)).join('');
}
---

<section class="py-24 bg-white overflow-hidden relative border-y border-border/40">
    <div class="container mx-auto px-4 relative">
        <div class="max-w-4xl mx-auto">
            <div class="space-y-12">
                <div class="flex justify-center">
                    <div class="inline-flex items-center gap-4">
                        <div class="h-px w-8 bg-primary/30"></div>
                        <span class="text-[10px] font-bold uppercase tracking-[0.4em] text-primary">{badge}</span>
                        <div class="h-px w-8 bg-primary/30"></div>
                    </div>
                </div>

                <div class="prose prose-xl prose-serif max-w-none text-center">
                    <p class="font-serif text-3xl md:text-4xl text-foreground leading-[1.4] italic font-light mb-12">
                        {quote}
                    </p>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-12 text-lg text-muted-foreground leading-relaxed font-light text-left">
                        <div class="space-y-6" set:html={leftContent} />
                        <div class="space-y-6" set:html={rightContent} />
                    </div>
                </div>

                <div class="flex justify-center pt-12">
                    <div class="w-24 h-px bg-border"></div>
                </div>
            </div>
        </div>
    </div>
</section>

<style>
    .prose-serif {
        --tw-prose-body: var(--foreground);
        --tw-prose-headings: var(--foreground);
        --tw-prose-italic: var(--primary);
    }
</style>
